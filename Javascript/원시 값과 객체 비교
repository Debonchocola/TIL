### 원시 값의 특징

1. 변경 불가능한 값
2. 원시 값을 할당하면 실제 값이 저장된다.
3. 다른 변수에 원시값을 가진 변수를 할당하면 원시 값이 복사되어 전달된다.

1번의 변경 불가능한 이란 의미는 변수가 변경 불가능하다는 말이 아니다.

변수의 경우 원시 값을 재 할당 하면 새로운 메모리 공간을 확보하고 저장한 후,

참조 하던 메모리 공간의 주소를 변경한다.

문자열은 유사배열이다.

```jsx
//문자열은 유사 배열이므로 인덱스를 사용해 접근할 수 있고, length도 사용가능
let str = 'string'

str[0] = 'S'

console.log(str); //string
//변경해도 반영되지 않는다. 읽기전용  이는 데이터의 신뢰성을 보장한다.
```

```jsx
let score = 80;
let copy = score;
let score = 100;
console.log(score, copy); //100 80
```

식별자는 메모리 주소에 붙인 이름이다.

객체의 경우는 값이 변경이 가능하기 때문에 참조 값이 변하지 않고 그 안의 값이 변한다.

여러 개의 식별자가 객체를 공유할 수 있다.

```jsx
const o = {x: {y : 1}};

//얕은 복사
const c1 = {...o};
console.log(c1 === o); //false
console.log(c1.x === o.x); //true

//깊은 복사
const _ = require('lodash');

const c2 = _.cloneDeep(o);
console.log(c2 === o) //false
console.log(c2.x === o.x); //false

```

얕은 복사는 참조 값을 복사하고 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사해서 

원시 값 처럼 완전한 복사본을 만든다는 차이가 있다.

함수 호출 방식에는 크게 2가지가 있다.

Call by value(값에 의한 호출, 값의 복사)
Call by reference(참조에 의한 호출, 주소의 복사)

일반적으로 기본형(원시형)을 매개변수로 넘길 때는 Call by value 방식으로 넘기고
참조형을 매개변수로 넘길 때는 Call by reference 방식으로 넘긴다.

기본형(원시형) : 숫자, 문자열, 불리언, null, undefiend, 심볼
참조형 : 객체, 배열, 함수, 날짜, 정규표현식

Call by value(값의 복사)는 말 그대로 복사된 값을 인자로 넘겨서 매개변수로 전달한다.

장점 : 복사하여 처리하기 때문에 안전하다. 원래의 값이 보존이 된다.
단점 : 복사를 하기 때문에 메모리가 사용량이 늘어난다.

Call by reference(주소값의 복사)는 실제 데이터가 존재하는 주소를 가리키는 주소값을 인자로 넘겨서 매개변수로 전달한다.

장점 : 복사하지 않고 직접 참조를 하기에 빠르다.
단점 : 직접 참조를 하기에 원래 값이 영향을 받는다.(리스크)

신기했던 점은 객체,배열은 이렇게 동작하는지 알았는데
함수의 경우 기본형을 넣어도 스왑이 일어나지 않는
const swap = (a, b) => {
  let tmp = a;
  a = b;
  b = tmp
}

let x = 1;
let y = 2;

swap(x, y);
console.log(x, y); // 1, 2
이런 예제를 보며 개념을 다시 익혔다.

const a = { 'a': 1 };
const b = (c) => {
  c.a = 2;
} 
b(a);
console.log(a) // { a: 2 }
이 경우 다른 주소값을 갖지만 똑같은 {'a': 1} 이라는 값을 바라보고 있기 때문이다.
