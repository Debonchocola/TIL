전역 변수의 문제점과 전역 변수의 사용을 억제할 수 있는 방법을 살펴보자.

전역 변수의 경우 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행된다.

  함수 내부에서 선언된 변수는 함수가 호출된 직후 함수 몸체의 코드가 실행되기 전에 자바스크립트 엔진에 의해 먼저 실행된다.

  ```jsx
  function foo() {
    var x = 'local';  --
    console.log(x);     |. 변수 x의 생명주기
    return x;         __
  }

  foo();
  console.log(x);
  ```

  호이스팅은 스코프를 단위로 동작한다.

  ```jsx
  var x = 'global';

  function foo() {
    console.log(x); // local
    var x = 'local';
  }

  foo();
  console.log(x); // global
  ```

  전역변수의 경우 반환문이 없기 때문에 마지막 문이 실행되어

  더 이상 실행할 문이 없을 때 종료한다.

  전역변수의 생명 주기가 전역 객체의 생명 주기와 일치한다.
  
  ### 14.2 전역 변수의 문제점

  암묵적 결합

  변수의 유효 범위가 크면 클수록 코드의 가독성은 나빠지고 의도치 않게 

  상태가 변경될 수 있는 위험성도 높아진다.
  
  긴 생명 주기

    전역 변수는 생명 주기가 길다. 따라서 메모리 리소스도 오랜 기간 소비한다.

    생명 주기가 길기 때문에 변수의 이름이 중복될 가능성이 있어서 재할당이 이뤄질 수 있다.
    

  스코프 체인 상에서 종점에 존재

    검색 속도의 차이는 그다지 크지 않지만 속도의 차이는 분명히 있다.

  네임스페이스 오염

    자바스크립트는 파일이 분리되어 있다 해도 하나의 전역 스코프를 공유하기 때문에

    동일한 이름으로 명명된 전역 변수나 전역 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과 발생
    
 ### 14.3 **전역 변수의 사용을 억제하는 방법**

  1) 즉시 실행 함수

    즉시 실행 함수는 단 한번만 호출된다. 모든 코드를 즉시 실행 함수로 감싸면

    모든 변수는 즉시 실행 함수의 지역 변수가 된다.
    
    (function () {
      var foo = 10;
    } ());
    console.log(foo); //ReferenceError: foo is not defined
    
   2) 네임스페이스 객체

    전역에 네임스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법
    
    var MYAPP = {};

    MYAPP.person = {
      name: 'Lee',
      address: 'Seoul'
    };

    console.log(MYAPP.person.name); // Lee
    식별자 충돌 방지하는 효과는 있으나 네임스페이스 객체 자체가 전역 변수에 할당 되므로 

    그닥 유용해 보이지 않는다.
    
  3) 모듈 패턴

    모듈 패턴은 클래스를 모방해서 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈

    을 만든다. 모듈 패턴은 자바스크립트의 강력한 기능인 클로저를 기반으로 동작한다.

    모듈패턴의 특징은 전역 변수 억제는 물론 캡슐화도 구현가능 하다.
    
    캡슐화란?

    객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작인 메서드를 하나로 

    묶는 것을 말한다. 특정 프로퍼티나 메서드를 감출 목적으로 사용하기도 하는데 이를 은닉이라 한다.
    
    var Counter = (function () {
      var num = 0;

      return {
        increase() {
          return ++num;
        },
        decrease() {
          return --num;
        }
      };
    }());

    //private 변수는 외부로 노출되지 않는다.
    console.log(Counter.num); //undefined

    console.log(Counter.increase()); //1
    console.log(Counter.increase()); //2
    console.log(Counter.decrease()); //1
    console.log(Counter.decrease()); //0
